{"mappings":"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","sources":["node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-f3729992d7387ebe.js","src/actors/Actor.ts","src/utils/angleToRad.ts","src/utils/keyboardMap.ts","node_modules/@parcel/runtime-js/lib/runtime-96a3796b07ba5f8e.js","src/actors/Car.ts","src/utils/checkLimits.ts","src/actors/Barrier.ts","src/state/Circuit.ts","src/actors/Chronometer.ts","src/actors/FPSViewer.ts","src/actors/LapCounter.ts","src/script.ts"],"sourcesContent":["\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"bHNlO\\\":\\\"index.1e531a63.js\\\",\\\"6uka6\\\":\\\"ferrari.fa972be2.png\\\"}\"));","import { Point } from \"../types/Point\";\n\nexport interface IActor {\n\tposition?: Point;\n\tupdate: (delta: number) => void;\n\tkeyboard_event_down?: (key: string) => void;\n\tkeyboard_event_up?: (key: string) => void;\n\tdraw: (delta: number, ctx: CanvasRenderingContext2D) => void;\n}\n\nexport class Actor implements IActor {\n\tposition: Point;\n\tconstructor(position: Point) {\n\t\tthis.position = position;\n\t}\n\tupdate(delta: number) { }\n\tdraw(delta: number, ctx: CanvasRenderingContext2D) { }\n\tkeyboard_event(key: string) { }\n}","export const angleToRad = (angle: number) => (angle * Math.PI) / 180;\n","export enum Carkey {\n\tUP,\n\tDOWN,\n\tLEFT,\n\tRIGHT,\n}\n\nexport interface KeyboardMap {\n\t[key: string]: Carkey;\n}\n\nexport let MAP_A = {\n\tArrowUp: Carkey.UP,\n\tArrowDown: Carkey.DOWN,\n\tArrowLeft: Carkey.LEFT,\n\tArrowRight: Carkey.RIGHT,\n};\nexport let MAP_B = {\n\tw: Carkey.UP,\n\ts: Carkey.DOWN,\n\ta: Carkey.LEFT,\n\td: Carkey.RIGHT,\n};","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"6uka6\")).toString();","import { Actor, IActor } from \"./Actor\";\nimport { Point } from \"../types/Point\";\nimport { angleToRad } from \"../utils/angleToRad\";\nimport { checkLimits } from \"../utils/checkLimits\";\nimport { Carkey, KeyboardMap } from \"../utils/keyboardMap\";\nconst ferrariImg = require(\"../assets/ferrari.png\");\n\ntype Size = { w: number; h: number };\n\nexport class Car extends Actor implements IActor {\n\tcarSize: Size;\n\tcarColor: string;\n\tangle: number;\n\tangleSpeed: number;\n\tcarSpeed: number;\n\tcarAcceleration: number;\n\timage: HTMLImageElement;\n\tkeyboardMap: KeyboardMap;\n\tconstructor(\n\t\tinitialPos: Point,\n\t\tkeyboardMap: KeyboardMap,\n\t\tsize: Size = { w: 50, h: 100 },\n\t) {\n\t\tsuper(initialPos);\n\t\tthis.keyboardMap = keyboardMap;\n\t\tthis.carSize = size;\n\t\tthis.carColor = \"red\";\n\t\tthis.angle = 0;\n\t\tthis.angleSpeed = 0;\n\t\tthis.carSpeed = 0;\n\t\tthis.carAcceleration = 0;\n\n\t\t// Car image\n\t\tthis.image = new Image();\n\t\tthis.image.src = ferrariImg;\n\t}\n\tupdate(delta: number) {\n\t\tthis.angle += this.angleSpeed;\n\t\tthis.angleSpeed *= 0.9;\n\t\t// Establecemos una velocidad en relación a la aceleración\n\t\tthis.carSpeed = this.carSpeed * 0.9 + this.carAcceleration;\n\t\t// console.log(this.carSpeed);\n\t\tlet newPos: Point = {\n\t\t\tx: this.position.x + Math.cos(angleToRad(this.angle)) * this.carSpeed,\n\t\t\ty: this.position.y + Math.sin(angleToRad(this.angle)) * this.carSpeed,\n\t\t};\n\t\tif (checkLimits(newPos)) {\n\t\t\tthis.position = newPos;\n\t\t}\n\t}\n\tdraw(delta: number, ctx: CanvasRenderingContext2D) {\n\t\tctx.fillStyle = this.carColor;\n\t\tctx.translate(this.position.x, this.position.y);\n\t\tctx.rotate(angleToRad(this.angle));\n\t\tctx.rotate(angleToRad(180));\n\t\tctx.drawImage(this.image, -50, -25, 100, 50);\n\t}\n\tkeyboard_event_down(key: string) {\n\t\tlet tecla = this.keyboardMap[key];\n\t\tif (tecla == Carkey.LEFT) {\n\t\t\tthis.angleSpeed -= 4;\n\t\t} else if (tecla == Carkey.RIGHT) {\n\t\t\tthis.angleSpeed += 4;\n\t\t} else if (tecla == Carkey.UP) {\n\t\t\tthis.carAcceleration = 0.5;\n\t\t} else if (tecla == Carkey.DOWN) {\n\t\t\tthis.carAcceleration = -0.5;\n\t\t}\n\t}\n\tkeyboard_event_up(key: string) {\n\t\tlet tecla = this.keyboardMap[key];\n\t\tif (tecla == Carkey.UP) {\n\t\t\tthis.carAcceleration = 0;\n\t\t} else if (tecla == Carkey.DOWN) {\n\t\t\tthis.carAcceleration = 0;\n\t\t}\n\t}\n}","import { Point } from \"../types/Point\";\nexport const checkLimits = (position: Point) => {\n\tif (\n\t\tposition.x < 1020 &&\n\t\tposition.x > 0 &&\n\t\tposition.y < 1024 &&\n\t\tposition.y > 0\n\t) {\n\t\treturn true;\n\t}\n\treturn false;\n};","import { Circuit } from \"../state/Circuit\";\nimport { Point } from \"../types/Point\";\nimport { angleToRad } from \"../utils/angleToRad\";\nimport { Actor, IActor } from \"./Actor\";\n\nexport class Barrier extends Actor {\n\tbarrierWith: number;\n\tangle: number;\n\tcar: IActor;\n\ttouched: boolean;\n\tbarrierindex: number;\n\tconstructor(\n\t\tinitialPos: Point,\n\t\tbw = 100,\n\t\tangle: number = 45,\n\t\tcar: IActor,\n\t\tbarrierindex: number,\n\t) {\n\t\tsuper(initialPos);\n\t\tthis.barrierWith = bw;\n\t\tthis.angle = angle;\n\t\tthis.car = car;\n\t\tthis.touched = false;\n\t\tthis.barrierindex = barrierindex;\n\t}\n\tupdate() {\n\t\tlet carPos = this.car.position;\n        if(carPos!== undefined){\n            let myPos = this.position;\n            let distance = Math.sqrt(\n                Math.pow(myPos.x - carPos.x, 2) + Math.pow(myPos.y - carPos.y, 2),\n            );\n            // console.log(Circuit.currentBarrier, this.barrierindex);\n            if (distance < 30) {\n                if (Circuit.touchingBarrier(this.barrierindex)) {\n                    this.touched = true;\n                }\n            }\n        }\n\t}\n\tdraw(delta: number, ctx: CanvasRenderingContext2D) {\n\t\t// Trasladamos y toamos el canvas según la barrera que vayamos a pintar\n\t\tctx.translate(this.position.x, this.position.y);\n\t\tctx.rotate(angleToRad(this.angle));\n\t\tthis.touched ? (ctx.strokeStyle = \"green\") : (ctx.strokeStyle = \"red\");\n\n\t\t// Pintamos una línea\n\t\tctx.lineWidth = 1;\n\t\tctx.beginPath();\n\t\tctx.moveTo(-this.barrierWith / 2, 0);\n\t\tctx.lineTo(this.barrierWith / 2, 0);\n\t\tctx.arc(0, 0, 3, 0, angleToRad(360));\n\t\tctx.closePath();\n\t\tctx.stroke();\n\t\tctx.fill();\n\t}\n}","import { IActor } from \"../actors/Actor\";\nimport { Barrier } from \"../actors/Barrier\";\nimport { angleToRad } from \"../utils/angleToRad\";\n\nclass CircuitManager {\n\tbarriers: Barrier[];\n\tcurrentBarrier: number;\n\tcurrentLap: number;\n\tchrono: number\n\tconstructor(actor: IActor) {\n\t\tthis.currentBarrier = 0;\n\t\tthis.currentLap = 0;\n\t\tthis.chrono = 0;\n\t\tlet barriers: Barrier[] = [];\n\t\tlet num = 20;\n\t\tlet increAngle = 360 / 10;\n\t\tlet center = { x: 500, y: 500 };\n\t\tlet radius = 400;\n\t\tfor (let i = 0; i < num; i++) {\n\t\t\tlet angle = (360 / num) * i;\n\t\t\tbarriers.push(\n\t\t\t\tnew Barrier(\n\t\t\t\t\t{\n\t\t\t\t\t\tx: center.x + Math.sin(angleToRad(angle)) * radius,\n\t\t\t\t\t\ty: center.y + Math.cos(angleToRad(angle)) * radius,\n\t\t\t\t\t},\n\t\t\t\t\t80,\n\t\t\t\t\t-angle + 90,\n\t\t\t\t\tactor,\n\t\t\t\t\ti,\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t\tconsole.log(\"CIRCUIT CREATED\");\n\t\tthis.barriers = barriers;\n\t}\n\tupdate(delta: number) {\n\t\tthis.chrono += delta\n\t}\n\taddLap() {\n\t\tconsole.log(\"LAP\");\n\t\tthis.currentLap++;\n\t\tthis.currentBarrier = 0;\n\t\tthis.barriers.forEach((b) => (b.touched = false));\n\n\t\tif (this.currentLap >= 1) {\n\t\t\talert(`YOU WON! Your score ${this.getChrono()}`);\n\t\t}\n\t}\n\tgetChrono() {\n\t\treturn `${this.chrono.toFixed(1)} segundos`\n\t}\n\tdraw() { }\n\ttouchingBarrier(idx: number) {\n\t\tif (this.currentBarrier == idx) {\n\t\t\tthis.currentBarrier++;\n\t\t\tif (this.currentBarrier == this.barriers.length) {\n\t\t\t\tthis.addLap();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nexport let Circuit: CircuitManager;\n\nexport const createCircuit = (actor: IActor) => {\n\tCircuit = new CircuitManager(actor);\n};","import { Actor } from \"./Actor\";\nimport { Circuit } from \"../state/Circuit\";\n\nexport class Chronometer extends Actor {\n    update() { }\n    keyboard_event() { }\n    draw(delta: number, ctx: CanvasRenderingContext2D) {\n        const chrono = Circuit.chrono.toFixed(1);\n        ctx.font = \"15px Arial\";\n        ctx.fillStyle = \"black\";\n        ctx.fillText(`CHRONO:${chrono} segundos`, this.position.x, this.position.y);\n    }\n}","import { Actor } from \"./Actor\";\n\nexport class FPSViewer extends Actor {\n\tupdate() {}\n\tkeyboard_event() {}\n\tdraw(delta: number, ctx: CanvasRenderingContext2D) {\n\t\tconst fps = (1 / delta).toFixed(2);\n\t\tctx.font = \"15px Arial\";\n\t\tctx.fillStyle = \"black\";\n\t\tctx.fillText(`FPS:${fps}`, this.position.x, this.position.y);\n\t}\n}","import { Actor } from \"./Actor\";\nimport { Circuit } from \"../state/Circuit\";\n\nexport class LapCounter extends Actor {\n    update() { }\n    keyboard_event() { }\n    draw(delta: number, ctx: CanvasRenderingContext2D) {\n        const laps = Circuit.currentLap;\n        ctx.font = \"15px Arial\";\n        ctx.fillStyle = \"black\";\n        ctx.fillText(`LAP:${laps}/1`, this.position.x, this.position.y);\n    }\n}","import { Actor, IActor } from \"./actors/Actor\";\nimport { Barrier } from \"./actors/Barrier\";\nimport { Car } from \"./actors/Car\";\nimport { Chronometer } from \"./actors/Chronometer\";\nimport { FPSViewer } from \"./actors/FPSViewer\";\nimport { LapCounter } from \"./actors/LapCounter\";\nimport { Circuit, createCircuit } from \"./state/Circuit\";\nimport { MAP_A, MAP_B } from \"./utils/keyboardMap\";\n\nwindow.onload = () => {\n  console.log('brum brum!');\n\n\tvar canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\n\tvar ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n\n\tlet fps = new FPSViewer({ x: 5, y: 15 });\n\tlet laps = new LapCounter({ x: 100, y: 15 });\n\tlet chrono = new Chronometer({ x: 200, y: 15 });\n\n\tlet carA = new Car({ x: 400, y: 900 }, MAP_A);\n\t// let carB = new Car({ x: 300, y: 300 }, MAP_B);\n\n\tlet cars = [carA];\n\n\tcreateCircuit(carA);\n\n\tlet actors: Array<IActor> = [fps, laps, chrono, Circuit, ...cars, ...Circuit.barriers];\n\n\tlet lastFrame = 0;\n\tconst render = (time: number) => {\n\t\tlet delta = (time - lastFrame) / 1000;\n\n\t\tlastFrame = time;\n\t\tactors.forEach((e) => e.update(delta));\n\t\tctx.clearRect(0, 0, canvas.width, canvas.height);\n\t\tactors.forEach((e) => {\n\t\t\tctx.save();\n\t\t\te.draw(delta, ctx);\n\t\t\tctx.restore();\n\t\t});\n\t\twindow.requestAnimationFrame(render);\n\t};\n\n\twindow.requestAnimationFrame(render);\n\n\tdocument.body.addEventListener(\"keydown\", (e) => {\n\t\t// console.log(e.key);\n\t\tactors.forEach((actor) => {\n\t\t\tif (actor.keyboard_event_down) {\n\t\t\t\tactor.keyboard_event_down(e.key);\n\t\t\t}\n\t\t});\n\t});\n\tdocument.body.addEventListener(\"keyup\", (e) => {\n\t\t// console.log(e.key);\n\t\tactors.forEach((actor) => {\n\t\t\tif (actor.keyboard_event_up) {\n\t\t\t\tactor.keyboard_event_up(e.key);\n\t\t\t}\n\t\t});\n\t});\n};\n"],"names":["$18c11f3350a906ea$export$6503ec6e8aabbaf","$18c11f3350a906ea$export$f7ad0328861e2f03","$18c11f3350a906ea$var$mapping","pairs","keys","Object","i","length","id","resolved","Error","parcelRequire","register","JSON","parse","$1be9d8d1634ad3ea$export$f73d3eb6fd876d80","constructor","position","this","update","delta","draw","ctx","keyboard_event","key","$87ebb3fba79fa37a$export$788095cfcbd7518","angle","Math","PI","$45ecd8466228168a$export$ea8005e43911f62a","$45ecd8466228168a$export$40b97bd9cab42943","ArrowUp","UP","ArrowDown","DOWN","ArrowLeft","LEFT","ArrowRight","RIGHT","$423a099a8203e18c$exports","URL","resolve","import","meta","url","toString","$21c417d024c263b9$export$91030e912f5b0749","initialPos","keyboardMap","size","w","h","super","carSize","carColor","angleSpeed","carSpeed","carAcceleration","image","Image","src","newPos","x","cos","y","sin","fillStyle","translate","rotate","drawImage","keyboard_event_down","tecla","keyboard_event_up","$ba22de8c10e7b95b$export$c1105631e00f9a4c","bw","car","barrierindex","barrierWith","touched","carPos","undefined","myPos","sqrt","pow","$b50c3765a2afc38c$export$74b434eeec43b766","touchingBarrier","strokeStyle","lineWidth","beginPath","moveTo","lineTo","arc","closePath","stroke","fill","$b50c3765a2afc38c$var$CircuitManager","actor","currentBarrier","currentLap","chrono","barriers","center","push","console","log","addLap","forEach","b","alert","getChrono","toFixed","idx","$a97ffe0330149eff$export$4fa45359d12c61eb","font","fillText","$e56a6a181a9d7472$export$13acb86b4b3ca30e","fps","$eef0084a0027081f$export$986afdc11aa5a9fe","laps","window","onload","canvas","document","getElementById","getContext","carA","cars","actors","lastFrame","render","time","e","clearRect","width","height","save","restore","requestAnimationFrame","body","addEventListener"],"version":3,"file":"index.1e531a63.js.map"}